%---------输入量归一化--------
%DT1=DT(:,[1,3:6,8:11,13:15]);%角度不再需要归一化
%for i=1:12
%    DT0(:,i)=DT1(1:400,i)./max(DT1(:,i));
%end
%DTA=[DT0(:,1:4),DT(1:400,2)]';
%DTB=[DT0(:,5:8),DT(1:400,7)]';
%DTC=[DT0(:,9:12),DT(1:400,12)]';
%Y=QD(1:400,1)./max(QD(:,1));


%%----------基本参量-----------
%T=50000;%最大训练次数
%n=12;%中间层神经元数
%v=0.035;%学习速度
%g=0.65E-3;%目标误差
%sam=400;%样本容量
%w2=rand(12,5);%一二间权值
%j2=rand(12,1);%二层的阈值
%w3=rand(1,12);%二三间权值
%j3=rand(1,1);%三层的阈值
%%--------神经网络的设置--------
%%---------第一层--------
%X1=DTA;
%X1=DTB;
%X1=DTC;
%I1=X1; %输入
%Y1=I1; %输出
%%---------第二层--------
%I2=w2*Y1+j2*ones(1,12);%输入
%Y2=1./(1+exp(-I2));%输出 单极S型函数
%%---------第三层--------
%I3=w3*Y2+j3*ones(1,1);%输入
%Y3=I3;%输出
%%----------误差平方和----------
%E=sum((Y(1,:)-Y3(1,:)).^2);
%%--------权值与阈值调整--------
%%-----二三层间权值变化--
%w30=-v*(Y-Y3)*Y2';
%%------第三层阈值变化---
%j30=-v*(Y-Y3)*ones(sam,1);
%%---- 一二层间权值变化--
%w20=-v*(w3'*(Y-Y3).*Y2.*(1-Y2))*I1';
%%------第二层阈值变化---
%j20=-v*(w3'*(Y-Y3).*Y2.*(1-Y2))*ones(sam,1);
%%-----调整后权值与阈值--
%w3=w3+w30;
%j3=j3+j30;
%w2=w2+w20;
%j2=j2+j20;
%%-----------------正式的运行程序------------------[
%w2=0.5*rand(12,5)-0.1;%一二间权值
%j2=0.5*rand(12,1)-0.1;%二层的阈值
%w3=0.5*rand(1,12)-0.1;%二三间权值
%j3=0.5*rand(1,1)-0.1;%三层的阈值
%Y1=X1;
%for t=1:T
%    I2=w2*Y1+j2*ones(1,sam);
%    Y2=1./(1+exp(-I2));
%    I3=w3*Y2+j3*ones(1,sam);
%    Y3=I3;
%    E=sum((Y(1,:)-Y3(1,:)).^2);
%    if E>g
%        w30=v*(Y-Y3)*Y2';
%        j30=v*(Y-Y3)*ones(sam,1);
%        w20=v*(w3'*(Y-Y3).*Y2.*(1-Y2))*Y1';
%        j20=v*(w3'*(Y-Y3).*Y2.*(1-Y2))*ones(sam,1);
%        w3=w3+w30;
%        j3=j3+j30;
%        w2=w2+w20;
%        j2=j2+j20;
%    else
%        break
%    end
%end

%运行前打开DT，PT,QD矩阵
DTA=DT(:,1:5)';
DTB=DT(:,6:10)';
DTC=DT(:,11:15)';
PTA=PT(:,1:5)';
PTB=PT(:,6:10)';
PTC=PT(:,11:15)';
Y0=QD(:,1)';
[Y,outr]=mapminmax(Y0);
[X1,intr]=mapminmax(DTB);
X2=mapminmax('apply',PTB,intr);
net=newff(X1,Y,[5 12 1],{'purelin','logsig','purelin'},'traingda');
net.trainParam.show=10;
net.trainParam.lr=0.05;
net.trainParam.epochs=50000;
net.trainParam.goal=0.06;
net.divideFcn='';
sam=400;
[BPnet,tr]=train(net,X1,Y);
y=sim(BPnet,X2);
Pb=mapminmax('reverse',y,outr);


